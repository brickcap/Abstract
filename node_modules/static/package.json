{
  "name": "static",
  "version": "1.0.0",
  "dependencies": {
    "handlebars": "~1.0",
    "marked": "0.2.7",
    "async": "0.1.22",
    "jsdom": "0.3.4",
    "underscore": "1.4.2",
    "highlight.js": "7.3.0"
  },
  "bin": {
    "static": "bin/static"
  },
  "readme": "Static\n======\n\nMarkdown and Handlebars static site generator. Transforms files with `.hbs` and `.md` with Handlebars and Markdown respectively.\n\n    npm install static\n\n## Command line interface\n\n    static source.hbs.html target.html\n\n## JavaScript interface\n\n    var static = require('./static');\n    static.transform('source.hbs.html', function(buffer) {\n      fs.writeFile('target.html', buffer.toString());\n    });\n\n## Grunt Interface\n\nIn your `Gruntfile.js`:\n\n    grunt.loadNpmTasks('static');\n\nThen in your config, define \"static\" as a multi task:\n\n    grunt.initConfig({\n      static: {\n        mySite: {\n          // this file will be included before the\n          // build is run\n          require: ['helpers.js'],\n          build: {\n            // will treat source as a handlebars\n            // template and save at target\n            'target.html': 'source.hbs.html',\n            // process multiple files into a single file\n            'api.html': [\n              'header.hbs.html',\n              'README.md',\n              'footer.html'\n            ],\n            // specify a specific context for the\n            // handlebars template to be run with\n            'target2.html': {\n              file: 'source.hbs.html',\n              context: {\n                key: 'value'\n              }\n            }\n          }\n        }\n      }\n    });\n\nIn this case, one could invoke: `grunt static:mySite` to run the build.\n\n`require` accepts an array of files to require before static runs, each file must export a function that will recieve a `static` object:\n\n    module.exports = function(static) {\n\n    };\n\n`build` accepts a hash of target file: source file pairs to process. If an array of source files is specified each one will be processed individually and concatenated. If compiling with handlebars an object may be passed that should be in this format:\n\n    {\n      file: 'source.hbs.html',\n      context: {\n        key: 'value'\n      }\n    }\n\nIn `source.hbs.html` `{{key}}` would be available.\n\n## Example\n\nA handlebars file similar to this could be used to generate documentation from a README.md file:\n\n    <ul class=\"toc\">\n      {{#include \"README.md\" select=\"h3\"}}\n        <li><a href=\"#{{id}}\">{{innerHTML}}</a></li>\n      {{/include}}\n    </ul>\n    <div class=\"body\">\n      {{include \"README.md\"}}\n    </div>\n\n## Handlebars API\n\n### include *{{include filename [select=selector]}}*\n\nInclude a file. If `select` is specified a block must be passed. The block will be called once for each selected node (with the context set to the node) from the file and the resulting HTML will be embedded.\n\n## JavaScript API\n\n### transform *static.transform(source, callback)*\n\nTransforms a given file with Handlebars and Markdown if file extensions are present. Calls callback with a buffer containing the transformed file.\n\n### handlebars *static.handlebars*\n\nA reference to the handlebars object static is using. Useful to register new helpers on.\n\n### registerAsyncHelper *static.handlebars.registerAsyncHelper(name, callback)*\n\nJust like `Handlebars.registerHelper` but async. `callback` recieves arguments to the helper (if any) followed by an options object, followed by a callback. Call the callback with your generated output instad of returning.\n\n    static.handlebars.registerAsyncHelper('toc', function(options, callback) {\n      static.transform('README.md', function(html) {\n        static.$(html, function(window) {\n          var output = '<ul>';\n          window.$('h3', function() {\n            output += '<li>' + this.innerHTML + '</li>'\n          });\n          callback(output + '</ul>');\n        });\n      });\n    });\n\n### $ *static.$(html, callback)* \n\nCreate a DOM window and jQuery object from the specified HTML. `callback` recieves `window` with jQuery initialized. The `select` argument to `include` is implemented with this.\n\n\n    static.$(html, function(window) {\n      window.$('a').each(...);\n    });\n\n### modifyDocumentFragment *static.modifyDocumentFragment(html, callback, next)*\n\nSimilar to `$`, calls `callback` with a `window` object initialized with jQuery. The `window` can be modified within the callback. `next` will be called with the resulting HTML.\n\n    static.modifyDocumentFragment('<ul></ul>', function(window) {\n      window.$('ul').append('<li></li>');\n    }, function(html) {\n      // html === '<ul><li></li></ul>'\n    });\n\n### onMarkdown *static.onMarkdown(callback)*\n\nCalled anytime after `transform` transforms a markdown document. `callback` is called with the generated HTML and a `next` function that must be called with the modified HTML. Pairs well with `modifyDocumentFragment`.\n\n    static.onMarkdown(function(html, next) {\n      next(html);\n    });\n\n### addTransform *static.addTransform(fileExtension, callback)*\n\nTransform files passed to *transform* based on file extension. `callback` recieves:\n- `buffer` - the file buffer\n- `callback` - to be called with the transformed buffer\n- `context` - context if transform was invoked from a handlebars helper\n- `data` - private handlebars data, also contains `file` which is a reference to the current file\n\nThe `html` extension is a noop and is implemented as:\n\n    static.addTransform('html', function(buffer, next, context, data) {\n      next(buffer);\n    });\n\n### config *static.config*\n\nDefaults to:\n  \n  {\n    addIdsToHeadings: true, //in markdown add ids to h[1-6] tags\n    gfm: true, //github flavored markdown\n    highlight: function(code, lang) {\n      return require('highlight.js').highlight(lang || 'javascript', code).value;\n    }\n  }\n",
  "readmeFilename": "README.md",
  "_id": "static@1.0.0",
  "description": "Static ======",
  "dist": {
    "shasum": "6151723b2f63c5759b5611931b3ceab9f3979c73"
  },
  "_from": "static@",
  "_resolved": "https://registry.npmjs.org/static/-/static-1.0.0.tgz"
}
